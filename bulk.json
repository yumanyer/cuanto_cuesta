[
  {
    "item": "Validación de user_id en controladores",
    "status": "⚠️",
    "comentario": "Es muy probable que la lógica para obtener el ID del usuario desde el token JWT se repita en cada controlador que necesita proteger una ruta (ej. crear, actualizar o eliminar una receta). Esto genera código duplicado.",
    "sugerencia": "Centraliza la verificación y extracción del usuario en un único middleware de autenticación (ej. `requireAuth`). Este middleware debería validar el token, buscar al usuario en la base de datos y adjuntar el objeto `user` completo o su `id` al objeto `req`. De esta forma, los controladores simplemente acceden a `req.user.id` con la garantía de que ya ha sido validado."
  },
  {
    "item": "Validación de datos de entrada (body, params)",
    "status": "⚠️",
    "comentario": "Realizar validaciones manuales con `if/else` dentro de cada controlador (ej. `if (!req.body.title)` ) mezcla la lógica de validación con la lógica de negocio, haciendo los controladores más largos y difíciles de leer.",
    "sugerencia": "Utiliza una librería como `Joi` o `express-validator` para crear un middleware de validación. Define un 'esquema' de validación para cada endpoint y aplícalo en la ruta antes de que la petición llegue al controlador. Si la validación falla, el middleware responde con un error 400 y el controlador no se ejecuta. \n\nEjemplo con `express-validator`: \n`router.post('/', [body('title').notEmpty(), body('servings').isInt({ min: 1 })], recipeController.createRecipe);`"
  },
  {
    "item": "Separación de responsabilidades (Arquitectura)",
    "status": "❌",
    "comentario": "Un patrón común es mezclar la lógica de negocio, las consultas a la base de datos (SQL o de ORM) y la manipulación de `req`/`res` dentro de los controladores. Esto viola el Principio de Responsabilidad Única (SRP) y acopla fuertemente las capas.",
    "sugerencia": "Refactoriza hacia una arquitectura en capas. Crea una 'Capa de Servicios' que contenga la lógica de negocio (ej. `RecipeService.js`). El controlador solo debe: 1. Extraer datos de `req`. 2. Llamar al servicio correspondiente. 3. Formatear y enviar la respuesta. El servicio, a su vez, llama a una 'Capa de Repositorio/Acceso a Datos' (ej. `RecipeRepository.js`) que es la única responsable de interactuar con la base de datos. Esto desacopla el framework (Express) de tu lógica de negocio."
  },
  {
    "item": "Manejo de errores centralizado",
    "status": "⚠️",
    "comentario": "El uso de bloques `try...catch` en cada controlador para manejar errores asíncronos es repetitivo y propenso a inconsistencias. Es fácil olvidar capturar un error o manejarlo de forma diferente en cada sitio.",
    "sugerencia": "Crea un middleware de manejo de errores centralizado. Este middleware se define con 4 argumentos `(error, req, res, next)` y se añade al final de tu archivo principal (`app.js` o `server.js`). Para evitar los `try...catch`, puedes envolver tus controladores asíncronos en una función de orden superior que capture los errores y los pase con `next(error)`. Librerías como `express-async-errors` hacen esto automáticamente."
  },
  {
    "item": "Optimización de consultas (Problema N+1)",
    "status": "❌",
    "comentario": "Al obtener una lista de recetas, es un error común hacer una consulta por cada receta para obtener sus ingredientes. Si pides 20 recetas, terminas haciendo 1 (recetas) + 20 (ingredientes) = 21 consultas, lo cual es muy ineficiente.",
    "sugerencia": "Utiliza `JOIN` en tus consultas SQL para obtener toda la información relacionada en una sola llamada a la base de datos. Si usas un ORM como Sequelize o TypeORM, aprende a usar el 'Eager Loading' (carga ansiosa) para incluir las relaciones necesarias (ej. `Recipe.findAll({ include: [Ingredient] })`)."
  },
  {
    "item": "Seguridad de JWT y Cookies",
    "status": "⚠️",
    "comentario": "Almacenar el JWT en `localStorage` del cliente es una práctica común pero vulnerable a ataques de Cross-Site Scripting (XSS). Un token de acceso con una vida muy larga también es un riesgo de seguridad si es robado.",
    "sugerencia": "Implementa un patrón de `access token` + `refresh token`. El `access token` (corta duración, ~15 min) se usa para autorizar peticiones. El `refresh token` (larga duración, ~7 días) se almacena de forma segura en una cookie `HttpOnly`, `Secure` y `SameSite=Strict`. Cuando el `access token` expira, se usa el `refresh token` para obtener uno nuevo de forma silenciosa. Esto mitiga los ataques XSS y permite revocar sesiones."
  },
  {
    "item": "Atomicidad en el manejo de stock",
    "status": "❌",
    "comentario": "Cuando un usuario 'cocina' una receta, la operación de descontar el stock de múltiples ingredientes debe ser atómica. Si actualizas el stock de la harina, pero falla al actualizar el de los huevos, la base de datos queda en un estado inconsistente.",
    "sugerencia": "Utiliza **transacciones** de base de datos para todas las operaciones que impliquen múltiples escrituras relacionadas. Envuelve la lógica de 'verificar stock' y 'descontar stock' de todos los ingredientes en una transacción. Si cualquier paso falla, se revierte (`ROLLBACK`) la transacción completa, garantizando la integridad de los datos."
  },
  {
    "item": "Consistencia en unidades de medida",
    "status": "⚠️",
    "comentario": "El sistema puede ser propenso a errores si las recetas usan unidades como 'taza' o 'cucharada', mientras que el stock de ingredientes se gestiona en unidades base como 'gramos' o 'mililitros'.",
    "sugerencia": "Estandariza una unidad base para cada tipo de medida en la base de datos (ej. gramos para masa, mililitros para volumen). Crea una tabla de conversión de unidades. Cuando un usuario añade un ingrediente a una receta (ej. '1 taza de harina'), el sistema debe convertir esa cantidad a la unidad base ('120 gramos de harina') antes de realizar cualquier cálculo de stock. Esto centraliza la lógica y evita errores."
  },
  {
    "item": "Verificación de permisos a nivel de recurso",
    "status": "✅",
    "comentario": "Asumo que además de verificar que un usuario está autenticado, también verificas que tiene permiso para modificar/eliminar un recurso específico (ej. que el `recipe.author_id` coincida con el `req.user.id`).",
    "sugerencia": "Si no lo estás haciendo, esto es crítico. Se puede crear un middleware `checkOwnership(Model)` que se coloque después de `requireAuth`. Este middleware buscaría el recurso por su ID, lo compararía con el ID del usuario autenticado y denegaría el acceso si no coinciden. Esto evita que un usuario modifique las recetas de otro."
  },
  {
    "item": "Manejo de errores no centralizado",
    "status": "❌",
    "comentario": "Actualmente, cada función de controlador tiene su propio bloque `try...catch` que devuelve una respuesta 500 genérica (ej. `{ message: 'Error al...' }`). Esto duplica código y oculta detalles valiosos del error, dificultando el 'debugging'. Además, el archivo `app.js` carece de un middleware de manejo de errores final.",
    "sugerencia": "Implementa un middleware de manejo de errores centralizado. Elimina los `try...catch` de los controladores y utiliza un paquete como `express-async-errors` para capturar automáticamente los errores asíncronos y pasarlos al middleware central. Este middleware puede entonces formatear la respuesta del error de manera consistente (ej. con `error.message` y `error.statusCode`) y registrarlo."
  },
  {
    "item": "Diseño de rutas no RESTful",
    "status": "⚠️",
    "comentario": "Las rutas de la API utilizan verbos en las URLs (ej. `/create`, `/get`, `/delete`). El estándar RESTful promueve el uso de métodos HTTP (POST, GET, PUT, DELETE) sobre un recurso raíz (ej. `/api/recetas`).",
    "sugerencia": "Refactoriza las rutas para seguir las convenciones REST. Por ejemplo:\n`POST /api/recetas` (para crear)\n`GET /api/recetas` (para obtener la lista)\n`GET /api/recetas/:id` (para obtener detalle)\n`PUT /api/recetas/:id` (para actualizar)\n`DELETE /api/recetas/:id` (para eliminar)\nEsto hace la API más predecible y estándar para los desarrolladores."
  },
  {
    "item": "Potencial vulnerabilidad de Inyección SQL",
    "status": "❌",
    "comentario": "El proyecto usa la librería `pg` directamente, sin un ORM o un 'query builder' visible. Si las consultas SQL se construyen concatenando strings con datos del usuario (ej. `\"SELECT * FROM recetas WHERE id = \" + req.params.id`), la aplicación es altamente vulnerable a ataques de inyección SQL.",
    "sugerencia": "Asegúrate de que **todas** las consultas a la base de datos se ejecuten utilizando consultas parametrizadas. La librería `pg` lo soporta nativamente. \n\nEjemplo: \n`const text = 'INSERT INTO users(name, email) VALUES($1, $2) RETURNING *'\nconst values = ['brianc', 'brian.m.carlson@gmail.com']\nconst res = await client.query(text, values)`\nNunca uses concatenación de strings para construir consultas."
  },
  {
    "item": "Abstracción de la lógica de negocio (Capa de Servicios)",
    "status": "⚠️",
    "comentario": "Los controladores instancian directamente los modelos (`new Recetas()`) y contienen lógica de negocio mezclada con la manipulación de `req`/`res`. Esto acopla fuertemente el controlador a la capa de datos y viola el Principio de Responsabilidad Única.",
    "sugerencia": "Crea una 'capa de servicio' (ej. `src/services/receta.service.js`). El controlador debe delegar toda la lógica de negocio al servicio. El controlador solo valida la entrada (a través de middleware), llama al servicio y envía la respuesta. El servicio contiene la lógica de negocio y se comunica con la capa de datos (modelos/repositorios). Esto mejora la testeabilidad y la separación de conceptos."
  },
  {
    "item": "Lógica de autenticación redundante en controladores",
    "status": "❌",
    "comentario": "En `recetas.controllers.js`, funciones como `createReceta` verifican la existencia de `req.user.id`. Esta comprobación es redundante, ya que el middleware `requireAuth` que se ejecuta antes en la ruta ya debería haber garantizado que el usuario está autenticado y haber abortado la petición en caso contrario.",
    "sugerencia": "Elimina todas las verificaciones manuales de `req.user.id` de los controladores. Confía en que el middleware `requireAuth` ha hecho su trabajo. Los controladores deben asumir que si llegan a ejecutarse, `req.user.id` está presente y es válido."
  },
  {
    "item": "Inconsistencia en el formato de las respuestas de la API",
    "status": "⚠️",
    "comentario": "Las respuestas de la API no siguen un formato consistente. Por ejemplo, `getRecetasUser` devuelve `{ message: '...', recetas: [...] }`, mientras que `getRecetaDetail` devuelve directamente el objeto de la receta. La inconsistencia hace que el frontend sea más difícil de implementar.",
    "sugerencia": "Estandariza un formato de respuesta para toda la API. Una estructura común es: \n`{ \"success\": true, \"data\": {...} }` para respuestas exitosas y \n`{ \"success\": false, \"error\": { \"code\": 404, \"message\": \"Not Found\" } }` para errores. Crea una función de utilidad para construir estas respuestas y úsala en todos los controladores."
  },
  {
    "item": "Gestión de la configuración y 'hardcoding'",
    "status": "⚠️",
    "comentario": "El archivo `app.js` contiene `console.log` para depuración y rutas a archivos estáticos que podrían cambiar entre entornos (desarrollo, producción). Aunque se usa un archivo `.env`, no toda la configuración parece estar centralizada.",
    "sugerencia": "Centraliza todas las configuraciones en `src/config/env.config.js`. Reemplaza los `console.log` de depuración por llamadas al logger `winston`. El logger puede configurarse para mostrar logs en la consola en desarrollo y escribirlos a un archivo en producción, ofreciendo más flexibilidad."
  },
  {
    "item": "Nomenclatura y consistencia de archivos",
    "status": "⚠️",
    "comentario": "Existe un archivo de middleware con un error tipográfico: `chechExistitReceta.middleware.js`. Esto puede generar confusión y dificultar la búsqueda de archivos.",
    "sugerencia": "Renombra el archivo a `checkRecipeExists.middleware.js` o un nombre más claro y consistente como `verifyRecipeOwnership.middleware.js`, y actualiza todas sus importaciones. Mantener una nomenclatura consistente y sin errores es crucial para la mantenibilidad del proyecto."
  }
]